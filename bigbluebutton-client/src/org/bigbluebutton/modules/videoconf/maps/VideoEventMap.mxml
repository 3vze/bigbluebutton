<?xml version="1.0" encoding="utf-8"?>

<!--

BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).

This program is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 3.0 of the License, or (at your option) any later
version.

BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.

-->

<EventMap xmlns:mx="http://www.adobe.com/2006/mxml" xmlns="http://mate.asfusion.com/">
	<mx:Script>
		<![CDATA[
      import org.bigbluebutton.core.events.ConnectAppEvent;
      import org.bigbluebutton.main.events.BBBEvent;
      import org.bigbluebutton.main.events.MadePresenterEvent;
      import org.bigbluebutton.main.events.StoppedViewingWebcamEvent;
      import org.bigbluebutton.main.events.UserJoinedEvent;
      import org.bigbluebutton.main.events.UserLeftEvent;
      import org.bigbluebutton.main.model.users.events.StreamStartedEvent;
      import org.bigbluebutton.modules.videoconf.events.ClosePublishWindowEvent;
      import org.bigbluebutton.modules.videoconf.events.ConnectedEvent;
      import org.bigbluebutton.modules.videoconf.events.ShareCameraRequestEvent;
      import org.bigbluebutton.modules.videoconf.events.StartBroadcastEvent;
      import org.bigbluebutton.modules.videoconf.events.StopBroadcastEvent;
      import org.bigbluebutton.modules.videoconf.model.VideoConfOptions;
      import org.bigbluebutton.modules.videoconf.views.PublishWindow;
      import org.bigbluebutton.modules.videoconf.views.ToolbarButton;
      import org.bigbluebutton.modules.videoconf.views.VideoWindow;
      import org.bigbluebutton.modules.viewers.events.ViewCameraEvent;
      import org.flexunit.runner.manipulation.filters.IncludeAllFilter;
			
			public var module:VideoconfModule;
			private var button:ToolbarButton;
			private var publishWindow:PublishWindow;
			public var proxy:VideoProxy;

			// This variable is used to avoid dispatching the BroadcastStoppedEvent
			// when the user just open the publish window and close it before start
			// publishing
			private var _publishing:Boolean = false;		
			
			private function viewCamera(userid:String, stream:String, name:String, mock:Boolean = false):void {
        LogUtil.debug("Viewing [" + userid + " stream [" + stream + "]");
				if (UserManager.getInstance().getConference().amIThisUser(userid)) return;
				
				var window:VideoWindow = new VideoWindow();
//				window.userId = userid;
				window.videoOptions = proxy.videoOptions;
				
				window.resolutions = module.resolutions.split(",");
				
				if (mock) {
					window.startVideo(module.mockConnection, stream);
				}
				else {
					window.startVideo(module.connection, stream);
				}
				window.title = name;
				var windowEvent:OpenWindowEvent = new OpenWindowEvent(OpenWindowEvent.OPEN_WINDOW_EVENT);
				windowEvent.window = window;
				globalDispatcher.dispatchEvent(windowEvent);
				
				// this event will dock the window, if it's enabled
				var openVideoEvent:OpenVideoWindowEvent = new OpenVideoWindowEvent();
				openVideoEvent.window = window;
				globalDispatcher.dispatchEvent(openVideoEvent);
			}

			private function viewVideoFile(e:BBBEvent):void {
				viewCamera("1", e.message, e.message, true);
			}
			
			private function mockConnect():void {
				module.mockConnect();
			}
			
			public function addToolbarButton():void{
				if (proxy.videoOptions.showButton) {
					button = new ToolbarButton();	  
					button.isPresenter = !module.presenterShareOnly;
					var event:ToolbarButtonEvent = new ToolbarButtonEvent(ToolbarButtonEvent.ADD);
					event.button = button;
					globalDispatcher.dispatchEvent(event);
				}
			}
			
			private function openPublishWindow():void{
				publishWindow = new PublishWindow();
				publishWindow.videoOptions = proxy.videoOptions;
				publishWindow.userrole = module.role;
				publishWindow.quality = module.quality;
				publishWindow.resolutions = module.resolutions.split(",");
				
				var windowEvent:OpenWindowEvent = new OpenWindowEvent(OpenWindowEvent.OPEN_WINDOW_EVENT);
				windowEvent.window = publishWindow;
				globalDispatcher.dispatchEvent(windowEvent);
			}
			


			private function closePublishWindow():void{
				publishWindow.close();
			}


			private function startPublishing(e:StartBroadcastEvent):void{
			    LogUtil.debug("Publishing stream to: " + proxy.connection.uri + "/" + e.stream);
				proxy.startPublishing(e);
				var broadcastEvent:BroadcastStartedEvent = new BroadcastStartedEvent();
				broadcastEvent.stream = e.stream;
				broadcastEvent.userid = module.userid;
				globalDispatcher.dispatchEvent(broadcastEvent);
				publishWindow.title = module.username + " (you)";
				_publishing = true;
				button.publishingStatus(button.START_PUBLISHING);

			}
			
			private function stopPublishing(e:StopBroadcastEvent):void{
				if (_publishing) {
					proxy.stopBroadcasting();
					
					var broadcastEvent:BroadcastStoppedEvent = new BroadcastStoppedEvent();
					broadcastEvent.stream = publishWindow.streamName;
					broadcastEvent.userid = module.userid;
					globalDispatcher.dispatchEvent(broadcastEvent);
					_publishing = false;
				}
				
				//Make toolbar button enabled again

				button.publishingStatus(button.STOP_PUBLISHING);
				//button.show();
			}
			
			public function stopModule():void {
				closeAllWindows();
				proxy.disconnect();
			}
			
			public function closeAllWindows():void{
				if (publishWindow != null) {
					proxy.stopBroadcasting();
					publishWindow.close();
				}
				globalDispatcher.dispatchEvent(new CloseAllWindowsEvent());
			}
			
			private function switchToPresenter():void{
        var options:VideoConfOptions = new VideoConfOptions();
        
				if (options.presenterShareOnly){
					button.isPresenter = true;
				}
			}
			
			private function switchToViewer():void{
				if (module.presenterShareOnly){
					button.isPresenter = false;
					if (publishWindow != null) publishWindow.close();
				}
			}
			
			
		]]>
	</mx:Script>
	
  <EventHandlers type="{VideoModuleStartEvent.START}">
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="start"/>
  </EventHandlers>
 
  <EventHandlers type="{VideoModuleStopEvent.STOP}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="stop"/>
  </EventHandlers>
  
  <EventHandlers type="{BBBEvent.CAMERA_SETTING}" >
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleCameraSetting" arguments="{event}"/>
  </EventHandlers>
  
  <EventHandlers type="{ConnectAppEvent.CONNECT_VIDEO_APP}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="connectToVideoApp" />
  </EventHandlers>
  
	<EventHandlers type="{ShareCameraRequestEvent.SHARE_CAMERA_REQUEST}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleShareCameraRequestEvent" arguments="{event}"/>
	</EventHandlers>

	<EventHandlers type="{StartBroadcastEvent.START_BROADCAST}" >
    <MethodInvoker generator="{VideoEventMapDelegate}" method="startPublishing" arguments="{event}" />
	</EventHandlers>
	
	<EventHandlers type="{StopBroadcastEvent.STOP_BROADCASTING}" >
    <MethodInvoker generator="{VideoEventMapDelegate}" method="stopPublishing" arguments="{event}" />
	</EventHandlers>
	
	<EventHandlers type="{StreamStartedEvent.STREAM_STARTED}">
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="viewCamera" arguments="{[event.userID, event.stream, event.user]}" />
	</EventHandlers>
	
	<EventHandlers type="{ViewCameraEvent.VIEW_CAMERA_EVENT}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="viewCamera" arguments="{[event.userID, event.stream, event.viewedName]}" />
	</EventHandlers>

  <EventHandlers type="{UserJoinedEvent.JOINED}">
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleUserJoinedEvent" arguments="{event}" />
  </EventHandlers>

  <EventHandlers type="{UserLeftEvent.LEFT}">
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleUserLeftEvent" arguments="{event}" />
  </EventHandlers>
  
	<EventHandlers type="{MadePresenterEvent.SWITCH_TO_PRESENTER_MODE}" >
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="switchToPresenter" arguments="{event}"/>	
	</EventHandlers>
	
	<EventHandlers type="{MadePresenterEvent.SWITCH_TO_VIEWER_MODE}">
    <ObjectBuilder generator="{VideoEventMapDelegate}" cache="global" constructorArguments="{scope.dispatcher}"/>
    <MethodInvoker generator="{VideoEventMapDelegate}" method="switchToViewer" arguments="{event}"/>
	</EventHandlers>

  <EventHandlers type="{ConnectedEvent.VIDEO_CONNECTED}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="connectedToVideoApp" />
  </EventHandlers>
 
  <EventHandlers type="{ClosePublishWindowEvent.CLOSE_PUBLISH_WINDOW}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleClosePublishWindowEvent" arguments="{event}"/>
  </EventHandlers>
  
  <EventHandlers type="{StoppedViewingWebcamEvent.STOPPED_VIEWING_WEBCAM}">
    <MethodInvoker generator="{VideoEventMapDelegate}" method="handleStoppedViewingWebcamEvent"  arguments="{event}"/>
  </EventHandlers>
  
  <!-- ~~~~~~~~~~~~~~~~~~    INJECTORS     ~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  
</EventMap>
